/*****************************************************
* This code is distributed under a Non-commercial use 
* license.  For details see LICENSE.  Use of this
* code must be properly attributed to its author
* Gregory E. Sims provided that its use or derivative 
* use is non-commercial in nature.  Proper attribution        
* can be made by citing:
*
* Sims GE, et al (2009) Alignment-free genome 
* comparison with feature frequency profiles (FFP) and 
* optimal resolutions. Proc. Natl. Acad. Sci. USA.
* 106, 2677-82.
*
* Gregory E. Sims (C) 2010-2012
*
*****************************************************/
/* _ HASH_H_ */
#ifndef _HASH_H_
#define _HASH_H_

#define BUCKETS 20013 /**< The Total number of buckets in feature hash table */
#define hashInc(X) hashAdd((X),(1)) /**< Macro for incrementing a key-value sotred in the hash */
#define numKeys(void)  keyN /**< Macro for number of keys in hash */


/** Linked list for storing values in the hash */

typedef struct node {
    char *key;	    /**< Key value for storing features */
    unsigned value;	    /**< Positive integer value for hash */
    struct node *next;	    /**< Pointer to next node in linked list */
} NODE;


NODE *table[BUCKETS];  /**< The hash table consisting of an Array of NODES */


int keyN; /**< The number of elements in the hash table */


/* function pointers */

int (*hashf) (register const char *);/**< A function ptr to a hashing function, set by initHash() */
int (*strcmpf) (register const char *, register const char *);/**< A ptr to a comparison function, set by initHash() */


/* prototypes */

void initHash(int bool, int bool2, int bool3);
int hashval(register char *s);
void hashKeys(char ***s);
int numKeys(void);
int freeHash(void);
//void hashAssign(char *s, int n);
//int hashAdd(char *s, unsigned val);
void hashValues(unsigned **values);
int hashDel(char *s);
int hashMax(char *s, unsigned val);


enum hash_modes { nucleotide, amino, text }; /**< Type of hash to initialize */




static const int base_ry_hash_values[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 2,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
}; /**< Character values for ry hash function */



static const int aac_values[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 2, 3, 3,
    4, 5, 6, 7, 0, 8, 7, 7, 9, 0,
    10, 8, 8, 11, 11, 0, 7, 4, 0, 4,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 2,
    3, 3, 4, 5, 6, 7, 0, 8, 7, 7,
    9, 0, 10, 8, 8, 11, 11, 0, 7, 4,
    0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
}; /**< Character values for classed amino acids */



static const int aa_hash_values[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 2, 3, 4,
    5, 6, 7, 8, 0, 9, 10, 11, 12, 0,
    13, 14, 15, 16, 17, 0, 18, 19, 0, 20,
    0, 0, 0, 0, 0, 0, 0, 1, 0, 2,
    3, 4, 5, 6, 7, 8, 0, 9, 10, 11,
    12, 0, 13, 14, 15, 16, 17, 0, 18, 19,
    0, 20, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
}; /**< Character values for amino acids */


static const int txt_hash_values[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 2, 3, 4, 5,
    6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 0, 0, 0, 0, 0, 0, 1, 2, 3,
    4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
};


#define hashAdd(S, VAL) \
do { \
    NODE * __ptrx; \
    NODE * __rx; \
    int __indexx; \
    \
    if ((__indexx = (*hashf) ((S))) >= 0) {	\
     \
    __ptrx = table[__indexx]; \
    \
    while (__ptrx != NULL) { \
	if ((*strcmpf) (__ptrx->key, (S)) == 0) { \
	    __ptrx->value += (VAL); \
		break; \
	} \
	__ptrx = __ptrx->next; \
    } \
    if (__ptrx == NULL ) { \
    __rx = (NODE *) malloc(sizeof(NODE)); \
    __rx->key = (char *) malloc(sizeof(char) * (Length + 1)); \
    strcpy(__rx->key, (S)); \
    __rx->value = (VAL); \
    __rx->next = table[__indexx]; \
    table[__indexx] = __rx; \
    keyN++; \
     } \
    } \
} while(0)





#define hashAssign(S,N)  \
   do { \
    NODE *__ptr; \
    __ptr = table[(*hashf)(S)]; \
    while (__ptr != NULL) { \
	if ((*strcmpf) (__ptr->key, (S) ) == 0) { \
		__ptr->value = (N); \
	    break; \
	} \
	__ptr = __ptr->next; \
    } \
   } while(0)



#endif				/* _HASH_H_ */
